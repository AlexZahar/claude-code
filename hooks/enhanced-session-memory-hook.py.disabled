#!/usr/bin/env python3
"""
Enhanced Session Memory Hook for Claude Code
Includes project detection, workspace context, and BoardLens-specific tracking
"""

import json
import sys
import subprocess
import os
import re
from datetime import datetime
from pathlib import Path
from collections import defaultdict

class BoardLensProjectDetector:
    """Detects and analyzes BoardLens project context"""
    
    BOARDLENS_PROJECTS = {
        'boardlens-frontend': {
            'type': 'frontend',
            'tech': 'Next.js',
            'port': 3000,
            'depends_on': ['boardlens-backend', 'boardlens-python-api']
        },
        'boardlens-backend': {
            'type': 'backend',
            'tech': 'Node.js/Express',
            'port': 3001,
            'depends_on': ['boardlens-python-api']
        },
        'boardlens-python-api': {
            'type': 'ai-engine',
            'tech': 'FastAPI/Python',
            'port': 5000,
            'depends_on': []
        },
        'boardlens-rag': {
            'type': 'rag-system',
            'tech': 'Python/LlamaIndex',
            'port': 8000,
            'depends_on': []
        }
    }
    
    @classmethod
    def detect_project(cls, cwd):
        """Detect which BoardLens project we're in"""
        path_parts = Path(cwd).parts
        
        for project in cls.BOARDLENS_PROJECTS:
            if project in path_parts:
                return project
                
        # Check if we're in the main boardlens directory
        if 'boardlens' in path_parts:
            return 'boardlens-workspace'
            
        return None
    
    @classmethod
    def get_project_info(cls, project_name):
        """Get detailed project information"""
        return cls.BOARDLENS_PROJECTS.get(project_name, {})

def get_enhanced_session_context():
    """Extract enhanced session context with BoardLens awareness"""
    # Basic context
    cwd = os.getcwd()
    project_name = BoardLensProjectDetector.detect_project(cwd)
    project_info = BoardLensProjectDetector.get_project_info(project_name) if project_name else {}
    
    # Get conversation content
    conversation_content = ""
    if not sys.stdin.isatty():
        try:
            conversation_content = sys.stdin.read()
        except:
            conversation_content = ""
    
    # Git context
    git_context = get_git_context(cwd)
    
    # Recent file changes
    recent_changes = get_recent_file_changes(cwd)
    
    # Active branches across projects
    workspace_branches = get_workspace_branches()
    
    # Modified files across workspace
    workspace_status = get_workspace_status()
    
    # Extract key topics from conversation
    conversation_topics = extract_conversation_topics(conversation_content)
    
    # Detect accessed projects from conversation
    accessed_projects = detect_accessed_projects(conversation_content)
    
    return {
        "cwd": cwd,
        "project_name": project_name,
        "project_info": project_info,
        "git_context": git_context,
        "recent_changes": recent_changes,
        "workspace_branches": workspace_branches,
        "workspace_status": workspace_status,
        "conversation_content": conversation_content,
        "conversation_topics": conversation_topics,
        "accessed_projects": accessed_projects,
        "timestamp": datetime.now()
    }

def get_git_context(cwd):
    """Get comprehensive git context"""
    try:
        branch = subprocess.check_output(['git', 'branch', '--show-current'], 
                                       cwd=cwd, stderr=subprocess.DEVNULL).decode().strip()
        
        status = subprocess.check_output(['git', 'status', '--porcelain'], 
                                       cwd=cwd, stderr=subprocess.DEVNULL).decode().strip()
        
        # Get recent commits
        commits = subprocess.check_output(['git', 'log', '--oneline', '-5'], 
                                        cwd=cwd, stderr=subprocess.DEVNULL).decode().strip()
        
        # Count changes
        status_lines = status.split('\n') if status else []
        modified_count = len([l for l in status_lines if l.startswith(' M')])
        new_count = len([l for l in status_lines if l.startswith('??')])
        
        return {
            "branch": branch,
            "clean": not bool(status),
            "modified_files": modified_count,
            "new_files": new_count,
            "recent_commits": commits.split('\n') if commits else []
        }
    except:
        return {"error": "Not a git repository"}

def get_recent_file_changes(cwd, hours=24):
    """Get files changed in the last N hours"""
    try:
        # Use git log to find recent changes
        since = f"{hours}.hours.ago"
        result = subprocess.check_output(
            ['git', 'log', f'--since={since}', '--name-only', '--pretty=format:'],
            cwd=cwd, stderr=subprocess.DEVNULL
        ).decode().strip()
        
        files = [f for f in result.split('\n') if f]
        return list(set(files))[:20]  # Limit to 20 most recent unique files
    except:
        return []

def get_workspace_branches():
    """Get active branches across all BoardLens projects"""
    branches = {}
    boardlens_base = Path.home() / "Projects" / "boardlens"
    
    for project in BoardLensProjectDetector.BOARDLENS_PROJECTS:
        project_path = boardlens_base / project
        if project_path.exists():
            try:
                branch = subprocess.check_output(
                    ['git', 'branch', '--show-current'],
                    cwd=str(project_path), stderr=subprocess.DEVNULL
                ).decode().strip()
                branches[project] = branch
            except:
                branches[project] = "unknown"
    
    return branches

def get_workspace_status():
    """Get modification status across all BoardLens projects"""
    status = {}
    boardlens_base = Path.home() / "Projects" / "boardlens"
    
    for project in BoardLensProjectDetector.BOARDLENS_PROJECTS:
        project_path = boardlens_base / project
        if project_path.exists():
            try:
                git_status = subprocess.check_output(
                    ['git', 'status', '--porcelain'],
                    cwd=str(project_path), stderr=subprocess.DEVNULL
                ).decode().strip()
                
                status[project] = {
                    "modified": bool(git_status),
                    "file_count": len(git_status.split('\n')) if git_status else 0
                }
            except:
                status[project] = {"error": "Unable to get status"}
    
    return status

def extract_conversation_topics(conversation):
    """Extract key technical topics from conversation"""
    topics = []
    
    # Common technical patterns
    patterns = {
        'api_endpoints': r'(GET|POST|PUT|DELETE|PATCH)\s+/[\w/\-{}]+',
        'file_paths': r'[/\w\-]+\.(js|jsx|ts|tsx|py|json|md|yaml|yml)',
        'functions': r'(function|def|const|class)\s+(\w+)',
        'imports': r'(import|from)\s+[\w\.\-]+',
        'errors': r'(error|exception|failed|issue):\s*.+',
        'config_keys': r'(NEXT_PUBLIC_|REACT_APP_|process\.env\.)[\w_]+',
    }
    
    for topic_type, pattern in patterns.items():
        matches = re.findall(pattern, conversation, re.IGNORECASE)
        if matches:
            topics.append({
                'type': topic_type,
                'count': len(matches),
                'samples': list(set(matches[:5]))  # First 5 unique matches
            })
    
    return topics

def detect_accessed_projects(conversation):
    """Detect which BoardLens projects were accessed/discussed"""
    accessed = []
    
    for project in BoardLensProjectDetector.BOARDLENS_PROJECTS:
        if project in conversation:
            accessed.append(project)
    
    # Also check for file paths
    boardlens_pattern = r'/(?:Users/\w+/)?Projects/boardlens/([\w\-]+)/'
    matches = re.findall(boardlens_pattern, conversation)
    
    for match in matches:
        if match in BoardLensProjectDetector.BOARDLENS_PROJECTS and match not in accessed:
            accessed.append(match)
    
    return accessed

def create_enhanced_memory_documentation(context, hook_type="session_end"):
    """Create enhanced memory documentation with BoardLens context"""
    timestamp = context['timestamp'].strftime("%Y-%m-%d %H:%M:%S")
    
    # Build project context section
    project_section = ""
    if context['project_name']:
        project_info = context['project_info']
        project_section = f"""
**Current Project:** {context['project_name']}
**Project Type:** {project_info.get('type', 'unknown')}
**Technology:** {project_info.get('tech', 'unknown')}
**Service Port:** {project_info.get('port', 'N/A')}
**Dependencies:** {', '.join(project_info.get('depends_on', [])) or 'None'}
"""
    
    # Build workspace status section
    workspace_section = ""
    if context['workspace_branches']:
        branch_lines = [f"  - {proj}: {branch}" for proj, branch in context['workspace_branches'].items()]
        workspace_section += f"\n**Active Branches:**\n" + "\n".join(branch_lines)
    
    if context['workspace_status']:
        status_lines = []
        for proj, status in context['workspace_status'].items():
            if status.get('modified'):
                status_lines.append(f"  - {proj}: {status['file_count']} files modified")
        if status_lines:
            workspace_section += f"\n\n**Modified Projects:**\n" + "\n".join(status_lines)
    
    # Build accessed projects section
    accessed_section = ""
    if context['accessed_projects']:
        accessed_section = f"\n**Projects Accessed This Session:**\n" + \
                          "\n".join([f"  - {proj}" for proj in context['accessed_projects']])
    
    # Build technical topics section
    topics_section = ""
    if context['conversation_topics']:
        topic_lines = []
        for topic in context['conversation_topics']:
            topic_lines.append(f"  - {topic['type']}: {topic['count']} occurrences")
        topics_section = f"\n**Technical Topics Discussed:**\n" + "\n".join(topic_lines)
    
    # Build recent changes section
    changes_section = ""
    if context['recent_changes']:
        changes_section = f"\n**Recent File Changes (24h):**\n" + \
                         "\n".join([f"  - {file}" for file in context['recent_changes'][:10]])
    
    documentation = f"""# BoardLens Session Memory - {timestamp}

## Date & Time Stamp
{timestamp}

## Session Overview
**Working Directory:** {context['cwd']}
**Hook Trigger:** {hook_type}
{project_section}

## Workspace Context
{workspace_section}
{accessed_section}

## Technical Findings
**Git Context:**
- Branch: {context['git_context'].get('branch', 'unknown')}
- Status: {'Clean' if context['git_context'].get('clean') else f"{context['git_context'].get('modified_files', 0)} modified, {context['git_context'].get('new_files', 0)} new files"}
- Recent Commits: {len(context['git_context'].get('recent_commits', []))}
{changes_section}
{topics_section}

## BoardLens Platform State
**Service Architecture:**
- Frontend (Next.js) → Port 3000
- Backend (Express) → Port 3001
- Python API (FastAPI) → Port 5000
- RAG System → Port 8000

**Key Integration Points:**
- Authentication: JWT with httpOnly cookies
- Document Processing: S3 → Backend → Python API → MongoDB/Pinecone
- AI Providers: OpenAI, Anthropic, Google AI, Cohere
- Vector Search: Pinecone
- Job Queue: Agenda/Redis

## Context for Continuation
**Development Environment:**
- Node.js v20.17.0 (ES Modules)
- Python 3.11+ with FastAPI
- MongoDB for data persistence
- Redis for caching and job queues
- AWS S3 for document storage

**Active Development Areas:**
{_extract_active_areas(context['conversation_content'])}

## Next Action Ready
{_generate_next_actions(context)}

## Session Memory Storage
- Location: ~/.claude/session-memories/
- Project Memories: ~/.claude/project-memories/[project-name]/
- Dependency Graph: ~/.claude/dependency-graphs/

## Conversation Excerpt
{context['conversation_content'][:1500] if context['conversation_content'] else "No conversation content captured"}
"""
    
    return documentation

def _extract_active_areas(conversation):
    """Extract active development areas from conversation"""
    areas = []
    
    # Keywords indicating active work
    active_patterns = {
        'implementing': r'implementing\s+([\w\s]+)',
        'fixing': r'fixing\s+([\w\s]+)',
        'adding': r'adding\s+([\w\s]+)',
        'updating': r'updating\s+([\w\s]+)',
        'refactoring': r'refactoring\s+([\w\s]+)',
    }
    
    for action, pattern in active_patterns.items():
        matches = re.findall(pattern, conversation, re.IGNORECASE)
        for match in matches[:3]:  # Limit to 3 per action
            areas.append(f"- {action.capitalize()}: {match.strip()}")
    
    return "\n".join(areas) if areas else "- No specific active areas detected"

def _generate_next_actions(context):
    """Generate contextual next actions based on session analysis"""
    actions = []
    
    # Check for uncommitted changes
    if context['workspace_status']:
        for proj, status in context['workspace_status'].items():
            if status.get('modified'):
                actions.append(f"- Review and commit changes in {proj} ({status['file_count']} files)")
    
    # Check for cross-project work
    if len(context['accessed_projects']) > 1:
        actions.append(f"- Ensure API contracts are synchronized between: {', '.join(context['accessed_projects'])}")
    
    # Add standard BoardLens checks
    if 'boardlens-backend' in context['accessed_projects']:
        actions.append("- Run `npm test` to ensure backend tests pass")
    
    if 'boardlens-frontend' in context['accessed_projects']:
        actions.append("- Run `npm run build` to verify frontend builds successfully")
    
    if 'boardlens-python-api' in context['accessed_projects']:
        actions.append("- Check `main.py` startup and ensure FastAPI endpoints are accessible")
    
    return "\n".join(actions) if actions else "- Continue with current development tasks"

# Update the main store function to also save project-specific memory
def store_enhanced_memory(documentation, context):
    """Store enhanced memory with project-specific copies"""
    try:
        # Save main session memory
        session_file = Path.home() / ".claude" / "session-memories" / f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        session_file.parent.mkdir(exist_ok=True)
        session_file.write_text(documentation)
        
        # If in a specific project, also save to project memory
        if context['project_name'] and context['project_name'] != 'boardlens-workspace':
            project_file = Path.home() / ".claude" / "project-memories" / context['project_name'] / "latest.md"
            project_file.parent.mkdir(exist_ok=True)
            project_file.write_text(documentation)
            
            # Keep a history (max 10 files)
            history_file = project_file.parent / f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            history_file.write_text(documentation)
            
            # Clean old history files
            history_files = sorted(project_file.parent.glob("session_*.md"))
            if len(history_files) > 10:
                for old_file in history_files[:-10]:
                    old_file.unlink()
        
        print(f"[Memory Hook] Enhanced session memory saved successfully")
        return True
        
    except Exception as e:
        print(f"[Memory Hook] Error storing enhanced memory: {e}")
        return False

def main():
    """Main hook execution"""
    try:
        hook_type = os.environ.get('CLAUDE_HOOK_TYPE', 'session_end')
        
        # Get enhanced session context
        context = get_enhanced_session_context()
        
        # Create the instance for the methods
        documenter = type('Documenter', (), {
            '_extract_active_areas': _extract_active_areas,
            '_generate_next_actions': _generate_next_actions
        })()
        
        # Bind methods to the function
        create_enhanced_memory_documentation._extract_active_areas = documenter._extract_active_areas
        create_enhanced_memory_documentation._generate_next_actions = documenter._generate_next_actions
        
        # Create enhanced documentation
        documentation = create_enhanced_memory_documentation(context, hook_type)
        
        # Store enhanced memory
        success = store_enhanced_memory(documentation, context)
        
        if success:
            print(f"[Memory Hook] BoardLens session memory successfully documented")
        else:
            print(f"[Memory Hook] Failed to store session memory")
            
    except Exception as e:
        print(f"[Memory Hook] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()